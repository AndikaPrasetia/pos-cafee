// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"
	"time"
)

const getDailySalesReportData = `-- name: GetDailySalesReportData :one
SELECT
    COALESCE(dss.total_orders, 0) AS total_orders,
    COALESCE(dss.total_sales, '0')::TEXT AS total_sales
FROM daily_sales_summary dss
WHERE dss.sale_date = $1::date
`

type GetDailySalesReportDataRow struct {
	TotalOrders int64  `db:"total_orders" json:"total_orders"`
	TotalSales  string `db:"total_sales" json:"total_sales"`
}

func (q *Queries) GetDailySalesReportData(ctx context.Context, dollar_1 time.Time) (GetDailySalesReportDataRow, error) {
	row := q.db.QueryRowContext(ctx, getDailySalesReportData, dollar_1)
	var i GetDailySalesReportDataRow
	err := row.Scan(&i.TotalOrders, &i.TotalSales)
	return i, err
}

const getFinancialSummaryByDateRange = `-- name: GetFinancialSummaryByDateRange :one
SELECT
    COUNT(o.id) AS total_orders,
    COALESCE(SUM(o.total_amount), '0')::TEXT AS total_sales,
    COALESCE(SUM(o.discount_amount), '0')::TEXT AS total_discount,
    COALESCE(SUM(o.tax_amount), '0')::TEXT AS total_tax
FROM orders o
WHERE o.status = 'completed'
AND o.completed_at IS NOT NULL
AND o.completed_at >= $1::timestamp
AND o.completed_at <= $2::timestamp
`

type GetFinancialSummaryByDateRangeParams struct {
	Column1 time.Time `db:"column_1" json:"column_1"`
	Column2 time.Time `db:"column_2" json:"column_2"`
}

type GetFinancialSummaryByDateRangeRow struct {
	TotalOrders   int64  `db:"total_orders" json:"total_orders"`
	TotalSales    string `db:"total_sales" json:"total_sales"`
	TotalDiscount string `db:"total_discount" json:"total_discount"`
	TotalTax      string `db:"total_tax" json:"total_tax"`
}

func (q *Queries) GetFinancialSummaryByDateRange(ctx context.Context, arg GetFinancialSummaryByDateRangeParams) (GetFinancialSummaryByDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getFinancialSummaryByDateRange, arg.Column1, arg.Column2)
	var i GetFinancialSummaryByDateRangeRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalSales,
		&i.TotalDiscount,
		&i.TotalTax,
	)
	return i, err
}

const getSalesByCategoryByDateRange = `-- name: GetSalesByCategoryByDateRange :many
SELECT
    c.name AS category_name,
    COUNT(oi.id) AS items_sold,
    SUM(oi.quantity) AS total_quantity,
    SUM(oi.total_price)::TEXT AS total_revenue
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN menu_items mi ON oi.menu_item_id = mi.id
JOIN categories c ON mi.category_id = c.id
WHERE o.status = 'completed'
AND o.completed_at IS NOT NULL
AND o.completed_at >= $1::timestamp
AND o.completed_at <= $2::timestamp
GROUP BY c.id, c.name
ORDER BY total_revenue DESC
`

type GetSalesByCategoryByDateRangeParams struct {
	Column1 time.Time `db:"column_1" json:"column_1"`
	Column2 time.Time `db:"column_2" json:"column_2"`
}

type GetSalesByCategoryByDateRangeRow struct {
	CategoryName  string `db:"category_name" json:"category_name"`
	ItemsSold     int64  `db:"items_sold" json:"items_sold"`
	TotalQuantity int64  `db:"total_quantity" json:"total_quantity"`
	TotalRevenue  string `db:"total_revenue" json:"total_revenue"`
}

func (q *Queries) GetSalesByCategoryByDateRange(ctx context.Context, arg GetSalesByCategoryByDateRangeParams) ([]GetSalesByCategoryByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesByCategoryByDateRange, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesByCategoryByDateRangeRow
	for rows.Next() {
		var i GetSalesByCategoryByDateRangeRow
		if err := rows.Scan(
			&i.CategoryName,
			&i.ItemsSold,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingItemsByDateRange = `-- name: GetTopSellingItemsByDateRange :many
SELECT
    mi.name AS menu_item_name,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.total_price)::TEXT AS total_revenue
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN menu_items mi ON oi.menu_item_id = mi.id
WHERE o.status = 'completed'
AND o.completed_at IS NOT NULL
AND o.completed_at >= $1::timestamp
AND o.completed_at <= $2::timestamp
GROUP BY mi.id, mi.name
ORDER BY total_quantity_sold DESC
LIMIT $3
`

type GetTopSellingItemsByDateRangeParams struct {
	Column1 time.Time `db:"column_1" json:"column_1"`
	Column2 time.Time `db:"column_2" json:"column_2"`
	Limit   int32     `db:"limit" json:"limit"`
}

type GetTopSellingItemsByDateRangeRow struct {
	MenuItemName      string `db:"menu_item_name" json:"menu_item_name"`
	TotalQuantitySold int64  `db:"total_quantity_sold" json:"total_quantity_sold"`
	TotalRevenue      string `db:"total_revenue" json:"total_revenue"`
}

func (q *Queries) GetTopSellingItemsByDateRange(ctx context.Context, arg GetTopSellingItemsByDateRangeParams) ([]GetTopSellingItemsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingItemsByDateRange, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingItemsByDateRangeRow
	for rows.Next() {
		var i GetTopSellingItemsByDateRangeRow
		if err := rows.Scan(&i.MenuItemName, &i.TotalQuantitySold, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
