// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createInventoryRecord = `-- name: CreateInventoryRecord :exec
INSERT INTO inventory (menu_item_id, current_stock, minimum_stock, unit)
VALUES ($1, 0, 0, 'pieces')
`

func (q *Queries) CreateInventoryRecord(ctx context.Context, menuItemID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, createInventoryRecord, menuItemID)
	return err
}

const getInventoryByMenuItem = `-- name: GetInventoryByMenuItem :one
SELECT id, menu_item_id, current_stock, minimum_stock, unit, last_updated_at, last_updated_by
FROM inventory
WHERE menu_item_id = $1
LIMIT 1
`

func (q *Queries) GetInventoryByMenuItem(ctx context.Context, menuItemID uuid.UUID) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByMenuItem, menuItemID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.MenuItemID,
		&i.CurrentStock,
		&i.MinimumStock,
		&i.Unit,
		&i.LastUpdatedAt,
		&i.LastUpdatedBy,
	)
	return i, err
}

const listInventory = `-- name: ListInventory :many
SELECT i.id, i.menu_item_id, mi.name as menu_item_name, i.current_stock, i.minimum_stock, 
       i.unit, i.last_updated_at, u.username as last_updated_by
FROM inventory i
JOIN menu_items mi ON i.menu_item_id = mi.id
LEFT JOIN users u ON i.last_updated_by = u.id
WHERE ($1::boolean IS NULL OR (i.current_stock <= i.minimum_stock) = $1)  -- low_stock_only
ORDER BY i.current_stock
LIMIT $2 OFFSET $3
`

type ListInventoryParams struct {
	Column1 bool  `db:"column_1" json:"column_1"`
	Limit   int32 `db:"limit" json:"limit"`
	Offset  int32 `db:"offset" json:"offset"`
}

type ListInventoryRow struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	MenuItemID    uuid.UUID      `db:"menu_item_id" json:"menu_item_id"`
	MenuItemName  string         `db:"menu_item_name" json:"menu_item_name"`
	CurrentStock  int32          `db:"current_stock" json:"current_stock"`
	MinimumStock  int32          `db:"minimum_stock" json:"minimum_stock"`
	Unit          string         `db:"unit" json:"unit"`
	LastUpdatedAt time.Time      `db:"last_updated_at" json:"last_updated_at"`
	LastUpdatedBy sql.NullString `db:"last_updated_by" json:"last_updated_by"`
}

func (q *Queries) ListInventory(ctx context.Context, arg ListInventoryParams) ([]ListInventoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listInventory, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryRow
	for rows.Next() {
		var i ListInventoryRow
		if err := rows.Scan(
			&i.ID,
			&i.MenuItemID,
			&i.MenuItemName,
			&i.CurrentStock,
			&i.MinimumStock,
			&i.Unit,
			&i.LastUpdatedAt,
			&i.LastUpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryStock = `-- name: UpdateInventoryStock :exec
UPDATE inventory
SET current_stock = $2, last_updated_at = NOW(), last_updated_by = $3
WHERE menu_item_id = $1
`

type UpdateInventoryStockParams struct {
	MenuItemID    uuid.UUID     `db:"menu_item_id" json:"menu_item_id"`
	CurrentStock  int32         `db:"current_stock" json:"current_stock"`
	LastUpdatedBy uuid.NullUUID `db:"last_updated_by" json:"last_updated_by"`
}

func (q *Queries) UpdateInventoryStock(ctx context.Context, arg UpdateInventoryStockParams) error {
	_, err := q.db.ExecContext(ctx, updateInventoryStock, arg.MenuItemID, arg.CurrentStock, arg.LastUpdatedBy)
	return err
}
